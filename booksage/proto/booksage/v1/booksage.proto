syntax = "proto3";

package booksage.v1;

option go_package = "github.com/booksage/booksage-api/internal/pb/booksage/v1;booksagev1";

// DocumentParserService handles the parsing of complex documents (PDF, EPUB, etc.)
// into structured markdown texts and metadata.
service DocumentParserService {
  // Parse accepts a stream of binary chunks from a document, and returns
  // the extracted metadata and markdown text chunks asynchronously.
  // Using client streaming to avoid hitting gRPC maximum message size (4MB limit).
  rpc Parse(stream ParseRequest) returns (ParseResponse);
}

// Request stream structure
message ParseRequest {
  oneof payload {
    // Initial metadata sent in the first message of the stream
    DocumentMetadata metadata = 1;
    // Sequential chunks of the document file, sent in subsequent messages
    bytes chunk_data = 2;
  }
}

// DocumentMetadata contains metadata about the file being parsed
message DocumentMetadata {
  string filename = 1;
  string file_type = 2;  // e.g., "application/pdf"
  string document_id = 3; // UUID or tracking ID generated by Orchestrator
}

// ParseResponse containing the parsed data
message ParseResponse {
  string document_id = 1;
  // Extracted metadata (title, author, etc.)
  map<string, string> extracted_metadata = 2;
  // The parsed document broken down into elements/chunks
  repeated RawDocument documents = 3;
}

// RawDocument represents a structural piece of the parsed document
// Could be a paragraph, a table, a list, etc., translated into standard Markdown.
message RawDocument {
  string content = 1; // Markdown string
  string type = 2;    // e.g., "table", "text", "heading"
  int32 page_number = 3; // Useful for PDF referencing
  // Provide map to accommodate flexible metadata for graph edges/summaries in the future
  map<string, string> metadata = 4;
}

// EmbeddingService handles text embedding operations.
service EmbeddingService {
  // GenerateEmbeddings accepts batches of text and returns their vector representations.
  rpc GenerateEmbeddings(EmbeddingRequest) returns (EmbeddingResponse);
}

// EmbeddingRequest accepts an array of strings to maximize GPU parallelization
// NOTE: Due to the 4MB default gRPC message size limit, clients MUST batch 
// requests (e.g., maximum 100 chunks per request) before calling this RPC.
message EmbeddingRequest {
  repeated string texts = 1;
  // Specify the model or embedding type, e.g., "colbert", "dense"
  string embedding_type = 2;
  // Strategy for task (e.g., "query", "document")
  string task_type = 3;
}

// EmbeddingResponse containing the corresponding vectors
message EmbeddingResponse {
  repeated EmbeddingResult results = 1;
  // Total tokens processed, useful for usage tracking
  int32 total_tokens = 2;
}

// EmbeddingResult encompasses various embedding formats
message EmbeddingResult {
  // Original text corresponding to this embedding
  string text = 1;

  // Use oneof to allow return of different vector formulations depending on the request
  oneof vector {
    DenseVector dense = 2;
    SparseVector sparse = 3;
    TensorVector tensor = 4; // e.g., for ColBERT token embeddings
  }
}

// DenseVector represents dense embeddings (e.g., 768 or 1536 dim floats)
message DenseVector {
  repeated float values = 1;
}

// SparseVector represents sparse embeddings (e.g., SPLADE)
message SparseVector {
  repeated int32 indices = 1;
  repeated float values = 2;
}

// TensorVector accommodates multi-dimensional embedding results like ColBERT
message TensorVector {
  // Flattened elements of a multi-dimensional array [seq_len, dim]
  repeated float values = 1;
  // Shape of the tensor to allow reconstruction
  repeated int32 shape = 2;
}
